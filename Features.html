
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Additional Features &#8212; dotty-cps-async 0.9.2 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Random Notes" href="random-notes/index.html" />
    <link rel="prev" title="Integrations" href="Integrations.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="random-notes/index.html" title="Random Notes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Integrations.html" title="Integrations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">dotty-cps-async 0.9.2 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Additional Features</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="additional-features">
<h1>Additional Features<a class="headerlink" href="#additional-features" title="Permalink to this headline">¶</a></h1>
<div class="section" id="automatic-coloring">
<h2>Automatic Coloring<a class="headerlink" href="#automatic-coloring" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, especially when we work with distributes systems, most of our API call are asynchronous and should be prefixed by <cite>await</cite>.  And we should remember what functions we should call as async and what - not.  It is known as ‘async coloring problem’: i.e. we should split our code technically into two parts (colors):  one works with async expressions (i.e.,, F[T]) and one - sync. (T without F).</p>
<p>If we want to put asynchronous expression into synchronous function, we should write <cite>await(expr)</cite>  instead <cite>expr</cite>,  for transforming synchronous code into asynchronous.
(see <a class="reference external" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/</a> for more detailed explanation )</p>
<p>In scala we have types, so why not to ask the compiler to do async coloring automatically?
So, next code:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">async</span><span class="o">[</span><span class="kt">Future</span><span class="o">]{</span>
   <span class="k">val</span> <span class="n">url</span> <span class="k">=</span> <span class="s">&quot;http://www.example.com&quot;</span>
   <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">await</span><span class="o">(</span><span class="n">api</span><span class="o">.</span><span class="n">fetchUrl</span><span class="o">(</span><span class="s">&quot;http://www.example.com&quot;</span><span class="o">))</span>
   <span class="k">val</span> <span class="n">theme</span> <span class="k">=</span> <span class="n">api</span><span class="o">.</span><span class="n">classifyText</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">dmpInfo</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">await</span><span class="o">(</span><span class="n">api</span><span class="o">.</span><span class="n">retrieveDMPInfo</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">await</span><span class="o">(</span><span class="n">theme</span><span class="o">),</span> <span class="s">&quot;1&quot;</span><span class="o">))</span>
   <span class="n">dmpInfo</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Can be written without await as:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">cps.automaticColoring.given</span>

<span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="n">async</span><span class="o">[</span><span class="kt">Future</span><span class="o">]{</span>
     <span class="k">val</span> <span class="n">url</span> <span class="k">=</span> <span class="s">&quot;http://www.example.com&quot;</span>
     <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">api</span><span class="o">.</span><span class="n">fetchUrl</span><span class="o">(</span><span class="s">&quot;http://www.example.com&quot;</span><span class="o">)</span>
     <span class="k">val</span> <span class="n">theme</span> <span class="k">=</span> <span class="n">api</span><span class="o">.</span><span class="n">classifyText</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
     <span class="k">val</span> <span class="n">dmpInfo</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">retrieveDMPInfo</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">theme</span><span class="o">,</span> <span class="s">&quot;1&quot;</span><span class="o">)</span>
     <span class="n">dmpInfo</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>If the underlying monad supports execution caching for using this feature (i.e., two awaits on the same expression should not cause reevaluation), then implicit await is enough for automatic coloring.  But what to do with pure effect monads, which holds computations without starting them?</p>
<p>Let’s look on the next code:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">updateCounter</span><span class="o">(</span><span class="n">counter</span><span class="k">:</span><span class="kt">Counter</span><span class="o">)</span> <span class="k">=</span> <span class="n">async</span><span class="o">[</span><span class="kt">IO</span><span class="o">]{</span>
  <span class="k">val</span> <span class="n">value</span> <span class="k">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="o">()</span>
  <span class="k">if</span> <span class="n">value</span> <span class="o">%</span> <span class="nc">LOG_MOD</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span>
     <span class="n">log</span><span class="o">(</span><span class="s">s&quot;counter value = </span><span class="si">${</span><span class="n">await</span><span class="o">(</span><span class="n">value</span><span class="o">)</span><span class="si">}</span><span class="s">&quot;</span><span class="o">)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="nc">LOG_TRESHOLD</span><span class="o">)</span> <span class="n">then</span>
     <span class="c1">// Conversion will not be appliyed for == .</span>
     <span class="c1">// For this example we want automatic conversion, so -1</span>
     <span class="n">log</span><span class="o">(</span><span class="s">&quot;counter TRESHOLD&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Assume IO is some pure effect monad, which holds a computation function that will be evaluated each time we need to get value from the monad. Counter.increment() is an IO action:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nc">Counter</span><span class="k">:</span>

  <span class="kt">def</span> <span class="kt">increment</span><span class="o">()</span><span class="kt">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</pre></div>
</div>
<p>The compiler will insert awaits when testing and printing value.
For making two using of <cite>val value</cite> be the same value, we need to memoize value during the creation of <cite>val</cite>.
Otherwise, the counter will be incremented three times instead of one.</p>
<dl class="simple">
<dt>Signature of memoization operation can be different for different monads, this can be:</dt><dd><ul class="simple">
<li><p><cite>memoize: F[X] =&gt; F[X]</cite>  for imperative monads.</p></li>
<li><p><cite>memoize: F[X] =&gt; F[F[X]]</cite>  for pure effect monads.  Internal <cite>F[_]</cite> holds cached computation. External <cite>F[_]</cite> - operation of getting a result from received cache. Flattening this expressin will return the original computation.</p></li>
</ul>
</dd>
<dt>If we want to provide support for automatic coloring for your monad, you should implement CpsMonadMemoization trait, which can be one of:</dt><dd><ul class="simple">
<li><p>CpsMonadDefaultMemoization - if computations are cached in your monad by default.</p></li>
<li><p>CpsMonadInplaceMemoization - for imperative monads</p></li>
<li><p>CpsMonadPureMemoization - for pure effect monads.</p></li>
<li><p>CpsMonadDynamicMemoization - for monads with custom memoization, which resolved with call-side types.</p></li>
</ul>
</dd>
<dt>Note, that automatic coloring for monads wich is not memoized by default (i.e. all effect monads) is hightly experimental and</dt><dd><p>likely will be changed in future.</p>
</dd>
</dl>
<p>Coloring rules are following:</p>
<blockquote>
<div><ul class="simple">
<li><p>If some variable is used only in a synchronous context (i.e., via await), the macro will color it as synchronous (i.e., cached if used more than once).</p></li>
<li><p>If some variable is passed to other functions as effect - it is colored as asynchronous (i.e., uncached).</p></li>
<li><p>If the variable is used in synchronous and asynchronous contexts simultaneously, we can’t deduce the programmer’s intention, and the coloring macro will report an error.</p></li>
<li><p>If the variable, defined outside of the async block, is used in synchronous context more than once - the macro also will report an error.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="custom-value-discard">
<h2>Custom value discard<a class="headerlink" href="#custom-value-discard" title="Permalink to this headline">¶</a></h2>
<p id="index-0">During the writing of asynchronous code, typical developers’ mistakes are to forget to handle something connected with discarded values, like error processing or awaiting.</p>
<p><code class="docutils literal notranslate"><span class="pre">cps.customValueDiscard</span></code>  limit the value discarding in the non-final expression in the block.  When enabled, value discarding is allowed only for those types T, for which exists an implementation of a special ValueDiscard[T]. If given ValueDiscard[T] is not found in the current scope, then dropping values of this type is prohibited.  If found - ValueDiscard.apply(t) is called. It’s defined as a no-op for primitive types and can be extended by the developer for its own types.</p>
<p>Example:</p>
<p>Assume we have next api:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">api</span><span class="k">:</span>
  <span class="kt">def</span>  <span class="kt">fetch</span><span class="o">(</span><span class="kt">url:</span> <span class="kt">string</span><span class="o">)</span><span class="kt">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span>  <span class="n">dryRun</span><span class="o">(</span><span class="n">data</span><span class="k">:</span><span class="kt">string</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span>  <span class="n">processData</span><span class="o">(</span><span class="n">data</span><span class="k">:</span><span class="kt">string</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre></div>
</div>
<p>Where the semantics of <cite>dryRun</cite>  - raise an error if it is impossible to run processData().</p>
<p>Let’s look at the next code:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">cps.customValueDiscard.given</span>

<span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="n">async</span><span class="o">[</span><span class="kt">Future</span><span class="o">]</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">await</span><span class="o">(</span><span class="n">api</span><span class="o">.</span><span class="n">fetch</span><span class="o">(</span><span class="s">&quot;http://www.example.com&quot;</span><span class="o">))</span>
   <span class="n">dryRun</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
   <span class="n">await</span><span class="o">(</span><span class="n">process</span><span class="o">(</span><span class="n">data</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here developer forgott to wrap <code class="docutils literal notranslate"><span class="pre">dryRun</span></code> in <code class="docutils literal notranslate"><span class="pre">await.</span></code>  But <code class="docutils literal notranslate"><span class="pre">customValueDiscard</span></code> feature is enabled and value discard operation is not defined for <code class="docutils literal notranslate"><span class="pre">`Future</span></code>, so this code will not compile.</p>
<p id="index-1">If you want to see warning instead error, you can import <cite>warnValueDiscard</cite> feature:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//import cps.feature.warnValueDiscard.given  //  &lt; 0.6.1</span>
<span class="k">import</span> <span class="nn">cps.warnValueDiscard.given</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note that custom value discarding is automatically enabled for effect monads to prevent situations where discarding values</dt><dd><p>drop branches in the computation flow.</p>
</dd>
</dl>
<p>Let’s look again at the code:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">updateCounter</span><span class="o">(</span><span class="n">counter</span><span class="k">:</span><span class="kt">Counter</span><span class="o">)</span> <span class="k">=</span> <span class="n">async</span><span class="o">[</span><span class="kt">IO</span><span class="o">]{</span>
  <span class="k">val</span> <span class="n">value</span> <span class="k">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="o">()</span>
  <span class="k">if</span> <span class="n">value</span> <span class="o">%</span> <span class="nc">LOG_MOD</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span>
     <span class="n">log</span><span class="o">(</span><span class="s">s&quot;counter value = </span><span class="si">${</span><span class="n">await</span><span class="o">(</span><span class="n">value</span><span class="o">)</span><span class="si">}</span><span class="s">&quot;</span><span class="o">)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="nc">LOG_TRESHOLD</span><span class="o">)</span> <span class="n">then</span>
     <span class="c1">// Conversion will not be appliyed for == . For this example we want automatic conversion, so -1</span>
     <span class="n">log</span><span class="o">(</span><span class="s">&quot;counter TRESHOLD&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Assuming that logging is IO operation, i.e. log have signature</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">message</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</pre></div>
</div>
<p>Without custom value discarding, the log statement will be dropped.  (Type of <cite>if</cite> with one branch is ‘Unit’, so type of the first branch should be ‘Unit’, so log statement will be discarded).
Dotty-cps-async provides special <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/ValueDiscard.scala#L27">AwaitValueDiscard</a>  which force monad to be evaluated before be discarded.  We recommend use this discard as default for IO[Unit].</p>
</div>
<div class="section" id="short-syntax-for-await">
<h2>Short syntax for await<a class="headerlink" href="#short-syntax-for-await" title="Permalink to this headline">¶</a></h2>
<p>It can be helpful when monad or environment does not support automatic coloring, but the default <cite>await</cite> syntax is too heavy.  For this case, we define <cite>unary_!</cite> operator for use instead of <cite>await</cite>.</p>
<p>Example:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">cps.syntax.</span><span class="n">`unary_!`</span>

<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">username</span> <span class="o">+</span> <span class="o">!</span><span class="n">fetchToken</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
</pre></div>
</div>
<p>Inside the async block this will be a synonim for</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">username</span> <span class="o">+</span> <span class="n">await</span><span class="o">(</span><span class="n">fetchToken</span><span class="o">(</span><span class="n">data</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="sip22-compatible-interface">
<h2>SIP22-compatible interface<a class="headerlink" href="#sip22-compatible-interface" title="Permalink to this headline">¶</a></h2>
<p id="index-2">This feature provides a compatibility layer for Scala2 <a class="reference external" href="https://docs.scala-lang.org/sips/async.html">SIP-22</a>
<a class="reference external" href="https://github.com/scala/scala-async">async</a>.
When migrating your program from legacy SIP22 to dotty, you can change the headers, from</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.async.Async.</span><span class="o">{</span><span class="n">async</span><span class="o">,</span><span class="n">await</span><span class="o">}</span>
</pre></div>
</div>
<p>to</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">cps.compat.sip22.</span><span class="o">{</span><span class="n">async</span><span class="o">,</span><span class="n">await</span><span class="o">}</span>
</pre></div>
</div>
<p>and use Future based async/await.</p>
<p>All test cases from the original Scala-Async distribution are passed with a change of imports only,
and included in our regression suite.</p>
<p>It is also possible to compile sip22 async code without changing of the source code with <a class="reference external" href="https://github.com/rssh/shim--scala-async--dotty-cps-async">shim–scala-async–dotty-cps-async</a> -s help.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.github.rssh&quot;</span> <span class="o">%%</span> <span class="s">&quot;shim-scala-async-dotty-cps-async&quot;</span> <span class="o">%</span> <span class="s">&quot;0.9.2&quot;</span><span class="o">,</span>
</pre></div>
</div>
<p>Note that compatibility was not a primary goal during the development of dotty-cps-async. Generated code is quite different, so if you need a bug-to-bug compatible version of scala2 async, you should use the port of the original -XAsync compiler plugin.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Additional Features</a><ul>
<li><a class="reference internal" href="#automatic-coloring">Automatic Coloring</a></li>
<li><a class="reference internal" href="#custom-value-discard">Custom value discard</a></li>
<li><a class="reference internal" href="#short-syntax-for-await">Short syntax for await</a></li>
<li><a class="reference internal" href="#sip22-compatible-interface">SIP22-compatible interface</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Integrations.html"
                        title="previous chapter">Integrations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="random-notes/index.html"
                        title="next chapter">Random Notes</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Features.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="random-notes/index.html" title="Random Notes"
             >next</a> |</li>
        <li class="right" >
          <a href="Integrations.html" title="Integrations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">dotty-cps-async 0.9.2 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Additional Features</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020-2021, Ruslan Shevchenko.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>